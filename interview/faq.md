# 前端面试常见的问题

1. 合并两个数组

> 合并数组有几种方法，可以列举一下：
>
> - concat:
>
> ```
> const arr1 = [1, 2, 3];
> const arr2 = [4, 5, 6];
> const finalArr = arr1.concat(arr2); // log: ['1', '2', '3', '4', '5', '6']
> ```
>
> **注意：** 需要进行多次的数组合并时，会造成很大的内存浪费
>
> - for 循环
>
> ```
> for (var i in arr2) {
>   arr1.push(arr2[i]);
> }
> ```
>
> **注意：** 可以解决内存浪费，但是代码不够简洁优雅
>
> - apply
>
>   每个函数的 apply 方法有一个特性，func.apply(obj, argv)，argv 是一个数组参数，那么我们就可以使用这个特性，将 arr2 数组传入 argv 参数，然后 func 是 arr1.push，则写成以下代码：
>
> ```
> arr1.push.apply(arr1,arr2) 相当于 arr1.push(arr2)
> ```

2. 内存泄漏

> sd

3. 闭包

>

4. 面向对象理解
5. 函数式编程理解
6. 斐波那契数列？怎么优化？
7. http 和 https 区别
8. https 建立的过程
9. 对微服务有什么了解？
10. 从数组中找出三数之和为 n
11. vue 和 react 的区别
12. react fiber 架构的理解
13. 实现一个 css 框架你有什么思路吗
14. 二分查找的时间复杂度怎么求？
15. 看过算法导论吗
16. 对图有了解吗
17. http 建立连接过程，为什么不是四次或两次握手
18. node 主要用来解决什么问题？
19. node 做 BFF 的优点是什么？
20. 对项目监控这块有什么了解吗？
21. 对微服务有了解吗
22. 聊一聊 docker？
23. 5g 时代的来临对前端有什么机遇与挑战？
24. Html4，html5 是建立在 http 上的，http 的下一代要解决什么问题？
25. 对现在主流前端框架的看法？
26. 看你有 github，你一般在 github 上做什么呢？
27. github 看过什么关于前端项目的源码？
28. 向什么源码提过 pr？
29. restful 接口架构的优缺点？
30. restful 接口架构会导致什么安全问题，具体怎么解决？

31. 谈谈你对重构的理解。

> 网站重构是指在不改变外部行为的前提下，简化结构、添加可读性，且在网站前端保持一致的行为。也就是说，在不改变 UI 的情况下，对网站进行优化，在扩展的同时保持一致的 UI。  
> 对于传统的网站来说，重构通常包括以下方面。
>
> - 把表格（ table）布局改为 DIV+CSS。
> - 使网站前端兼容现代浏览器。
> - 对移动平台进行优化。
> - 针对搜索引擎进行优化。
> - 深层次的网站重构应该考虑以下方面。
>   - 减少代码间的耦合
>   - 让代码保持弹性。
>   - 严格按规范编写代码。
>   - 设计可扩展的 API。
>   - 代替旧的框架、语言（如 VB）
>   - 增强用户体验。
>   - 对速度进行优化。
>   - 压缩 JavaScript、CSS、 image 等前端资源（通常由服务器来解决）。
>   - 优化程序的性能（如数据读写）。
>   - 采用 CDN 来加速资源加载。
>   - 优化 JavaScript DOM。
>   - 缓存 HTTP 服务器的文件。

32. 如果一个页面上有大量的图片（大型电商网站），网页加载很慢，可以用哪些方法优化这些图片的加载，从而提升用户体验？

> - 对于图片懒加载，可以为页面添加一个滚动条事件，判断图片是否在可视区域内或者即将进入可视区域，优先加载。
>
> - 如果为幻灯 32. 相册文件等，可以使用图片预加载技术，对于当前展示图片的前一张图片和后一张图片优先下载。
> - 如果图片为 CSS 图片，可以使用 CSS Sprit32. SVG sprite、 Icon font、Base64 等技术。
> - 如果图片过大，可以使用特殊编码的图片，加载时会先加载一张压缩得特别小的缩略图，以提高用户体验。
> - 如果图片展示区域小于图片的真实大小，则应在服务器端根据业务需要先行进行图片压缩，图片压缩后，图片大小与展示的就一致了。

33. 谈谈性能优化问题。

> 可以在以下层面优化性能。
>
> - 缓存利用：缓存 Ajax，使用 CDN、外部 JavaScript 和 CSS 文件缓存，添加 Expires 头，在服务器端配置 Etag，减少 DNS 查找等。
> - 请求数量：合并样式和脚本，使用 CSS 图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。
> - 请求带宽：压缩文件，开启 GZIP 。
> - CSS 代码：避免使用 CSS 表达式、高级选择器、通配选择器。
> - JavaScript 代码：用散列表来优化查找，少用全局变量，用 innerHTML 代替 DOM 操作，减少 DOM 操作次数，优化 JavaScript 性能，用 setTimeout 避免页面失去响应，缓存 DOM 节点查找的结果，避免使用 with（with 会创建自己的作用域，增加作用域链的长度），多个变量声明合并。
> - HTML 代码：避免图片和 iFrame 等 src 属性为空。src 属性为空，会重新加载当前页面，影响速度和效率，尽量避免在 HTML 标签中写 Style 属性

34. 移动端性能如何优化？

> 优化方式如下。
>
> - 尽量使用 CSS3 动画，开启硬件加速。
> - 适当使用 touch 事件代替 click 事件。
> - 避免使用 CSS3 渐变阴影效果。
> - 可以用 transform:translateZ（0）来开启硬件加速。
> - 不滥用 Float, Float 在渲染时计算量比较大，尽量少使用。
> - 不滥用 Web 字体，Web 字体需要下载、解析、重绘当前页面，尽量少使用。
> - 合理使用 requestAnimation Frame 动画代替 setTimeout。
> - 合理使用 CSS 中的属性（CSS3 transitions、CSS3 3D transforms、 Opacity、 Canvas、 WebGL、Video）触发 GPU 渲染。过度使用会使手机耗电量増加。

35. 如何对网站的文件进行优化?

> - 可以进行文件合并、文件压缩使文件最小化；
> - 可以使用 CDN 托管文件，让用户更快速地访问；
> - 可以使用多个域名来缓存静态文件。

36. 请说出几种缩短页面加载时间的方法。

> 具体方法如下。

> - 优化图片
> - 选择图像存储格式（比如，GIF 提供的颜色较少，可用在一些对颜色要求不高的地方）
> - 优化 CSS（压缩、合并 CSS）
> - 在网址后加斜杠
> - 为图片标明高度和宽度（如果浏览器没有找到这两个参数，它需要一边下载图片一边计算大小。如果图片很多，浏览器需要不断地调整页面。这不但影响速度，而且影响浏览体验。当浏览器知道高度和宽度参数后，即使图片暂时无法显示，页面上也会腾出图片的空位，然后继续加载后面的内容，从而优化加载时间，提升浏览体验）。

37. 哪些方法可以提升网站前端性能？

> - 精灵图(把一堆图标放在一张图里面，通过控制方位数值来调用相应图标)合并，减少 HTTP 请求；
> - 压缩 HTML、CSS、JavaScript 文件；
> - 使用 CDN 托管静态文件；
> - 使用 localstorage 缓存和 mainfest 应用缓存。

38. 你知道哪些优化性能的方法？

> 具体方法如下。
>
> - 减少 HTTP 请求次数，控制 CSS Sprite、JavaScript 与 CSS 源码、图片的大小，使用网页 Gzip、CDN 托管、data 缓存、图片服务器
> - 通过前端模板 JavaScript 和数据，减少由于 HTML 标签导致的带宽浪费，在前端用变量保存 Ajax 请求结果，每次操作本地变量时，不用请求，减少请求次数。
> - 用 innerhTML 代替 DOM 操作，减少 DOM 操作次数，优化 JavaScript 性能。
> - 当需要设置的样式很多时，设置 className 而不是直接操作 Style。
> - 少用全局变量，缓存 DOM 节点查找的结果，减少 I/O 读取操作
> - 避免使用 CSS 表达式，它又称动态属性，
> - 预加载图片，将样式表放在顶部，将脚本放在底部，加上时间戳。
> - 避免在页面的主体布局中使用表，表要在其中的内容完全下载之后才会显示出来，显示的速度比 DIV+CSS 布局慢。

39. 列举你知道的 Web 性能优化方法。

> 具体优化方法如下。
>
> - 压缩源码和图片（ JavaScript 采用混淆压缩，CSS 进行普通压缩，JPG 图片根据具体质量压缩为 50%~70%，把 PNG 图片从 24 色压缩成 8 色以去掉一些 PNG 格式信息等）.
> - 选择合适的图片格式（颜色数多用 JPG 格式，而很少使用 PNG 格式，如果能通过服务器端判断浏览器支持 WebP 就用 WebP 或 SVG 格式）。
> - 合并静态资源（减少 HTTP 请求）
> - 把多个 CSS 合并为一个 CSS，把图片组合成雪碧图。
> - 开启服务器端的 Gzip 压缩（对文本资源非常有效）。
> - 使用 CDN（对公开库共享缓存）。
> - 延长静态资源缓存时间。
> - 把 CSS 放在页面头部把 JavaScript 代码放在页面底部（这样避免阻塞页面渲染而使页面出现长时间的空白）

40. 平时你是如何对代码进行性能优化的？

> - 利用性能分析工具监测性能，包括静态 Analyze 工具和运行时的 Profile 工具（在 Xcode 工具栏中依次单击 Product→ Profile 项可以启动）。
> - 比如测试程序的运行时间，当单击 Time Profiler 项时，应用程序开始运行，这就能获取到运行整个应用程序所消耗时间的分布和百分比。为了保证数据分析在同一使用场景下的真实性，一定要使用真机，因为此时模拟器在 Mac 上运行，而 Mac 上的 CPU 往往比 iOS 设备要快。

41. 针对 CSS，如何优化性能？

> 具体优化方法如下。
>
> - 正确使用 display 属性， display 属性会影响页面的渲染，因此要注意以下几方面。
>   - display:inline 后不应该再使用 width、 height、 margin、 padding 和 float 。
>   - display:inline- block 后不应该再使用 float。
>   - display:block 后不应该再使用 vertical-align。
>   - display:table 后不应该再使用 margin 或者 float。
> - 不滥用 float。
> - 不声明过多的 font-size。
> - 当值为 0 时不需要单位。
> - 标准化各种浏览器前缀，并注意以下几方面。
>   - 浏览器无前缀应放在最后。
>   - CSS 动画只用（ -webkit-无前缀）两种即可。
>   - 其他前缀包括 -webkit-、-moz-、-ms-、无前缀（ Opera 浏览器改用 blink 内核，所以-0-被淘汰）
> - 避免让选择符看起来像是正则表达式。高级选择器不容易读懂，执行时间也长。
> - 尽量使用 id、 class 选择器设置样式（避免使用 style 属性设置行内样式）
> - 尽量使用 CSS3 动画。
> - 减少重绘和回流。

42. 针对 HTML，如何优化性能?

> 具体方法如下。
>
> - 对于资源加载，按需加载和异步加载
> - 首次加载的资源不超过 1024KB，即越小越好。
> - 压缩 HTML、CSS、 JavaScript 文件。
> - 减少 DOM 节点。
> - 避免空 src（空 src 在部分浏览器中会导致无效请求）。
> - 避免 30\*、40\*、50\*请求错误
> - 添加 Favicon.ico，如果没有设置图标 ico，则默认的图标会导致发送一个 404 或者 500 请求。

43. 针对 JavaScript，如何优化性能？

> 具体方法如下。
>
> - 缓存 DOM 的选择和计算。
> - 尽量使用事件委托模式，避免批量绑定事件。
> - 使用 touchstart、 touchend 代替 click。
> - 合理使用 requestAnimationFrame 动画代替 setTimeOut。
> - 适当使用 canvas 动画。
> - 尽量避免在高频事件（如 TouchMove、 Scroll 事件）中修改视图，这会导致多次渲染。

44. 如何优化服务器端？

> 具体方法如下。
>
> - 启用 Gzip 压缩。
> - 延长资源缓存时间，合理设置资源的过期时间，对于一些长期不更新的静态资源过期时间设置得长一些。
> - 减少 cookie 头信息的大小，头信息越大，资源传输速度越慢。
> - 图片或者 CSS、 JavaScript 文件均可使用 CDN 来加速。

45. 如何优化服务器端的接口？

> 具体方法如下。
>
> - 接口合并：如果一个页面需要请求两部分以上的数据接口，则建议合并成一个以减少 HTTP 请求数。
> - 减少数据量：去掉接口返回的数据中不需要的数据。
> - 缓存数据：首次加载请求后，缓存数据；对于非首次请求，优先使用上次请求的数据，这样可以提升非首次请求的响应速度。

46. 如何优化脚本的执行？

> 脚本处理不当会阻塞页面加载、渲染，因此在使用时需注意。
>
> - 把 CSS 写在页面头部，把 JavaScript 程序写在页面尾部或异步操作中。
> - 避免图片和 iFrame 等的空 src，空 src 会重新加载当前页面，影响速度和效率。
> - 尽量避免重设图片大小。重设图片大小是指在页面、CSS、 JavaScript 文件等中多次重置图片大小，多次重设图片大小会引发图片的多次重绘，影响性能
> - 图片尽量避免使用 DataURL。DataURL 图片没有使用图片的压缩算法，文件会变大，并且要在解码后再渲染，加载慢，耗时长。

47. 如何优化渲染？

> 具体方法如下。
>
> - 通过 HTML 设置 Viewport 元标签， Viewport 可以加速页面的渲染，如以下代码所示。
>
> ```
> <meta name="viewport" content="width=device=width,initial-scale=1">
> ```
>
> - 减少 DOM 节点数量，DOM 节点太多会影响页面的渲染，应尽量减少 DOM 节点数量。
> - 尽量使用 CSS3 动画，合理使用 requestAnimationFrame 动画代替 setTimeout，适当使用 canvas 动画（5 个元素以内使用 CSS 动画，5 个元素以上使用 canvas 动画（iOS 8 中可使用 webGL））。
> - 对于高频事件优化 Touchmove, Scroll 事件可导致多次渲染。
> - 使用 requestAnimationFrame 监听帧变化，以便在正确的时间进行渲染，增加响应变化的时间间隔，减少重绘次数。
> - 使用节流模式（基于操作节流，或者基于时间节流），减少触发次数。
> - 提升 GPU 的速度，用 CSS 中的属性（CSS3 transitions、CSS3 3D transforms、 Opacity、 Canvas、 WebGL、Video）来触发 GPU 渲染.

48. 如何设置 DNS 缓存？

> 在浏览器地址栏中输入 URL 以后，浏览器首先要查询域名（ hostname）对应服务器的 IP 地址，一般需要耗费 20~120ms 的时间。
> DNS 查询完成之前，浏览器无法识别服务器 IP，因此不下载任何数据。基于性能考虑，ISP 运营商、局域网路由、操作系统、客户端（浏览器）均会有相应的 DNS 缓存机制。
>
> - 正 IE 缓存 30min，可以通过注册表中 DnsCacheTimeout 项设置。
> - Firefox 混存 1 min，通过 network.dnsCacheExpiration 配置。
> - 在 Chrome 中通过依次单击“设置”→“选项”→“高级选项”，并勾选“用预提取 DNS 提高网页载入速度”选项来配置缓存时间。

49. 什么时候会出现资源访问失败？

> 开发过程中，发现很多开发者没有设置图标，而服务器端根目录也没有存放默认的 Favicon.ico，从而导致请求 404 出现。通常在 App 的 webview 里打开 Favicon.ico，不会加载这个 Favicon.ico，但是很多页面能够分享。如果用户在浏览器中打开 Favicon. ico，就会调取失败，一般尽量保证该图标默认存在，文件尽可能小，并设置一个较长的缓存过期时间。另外，应及时清理缓存过期导致岀现请求失败的资源。

50. jQuery 性能优化如何做？

> 优化方法如下。
>
> - 使用最新版本的 jQuery 类库。(JQuery 类库每一个新的版本都会对上一个版本进行 Bug 修复和一些优化，同时也会包含一些创新，所以建议使用最新版本的 jQuery 类库提高性能。不过需要注意的是，在更换版本之后，不要忘记测试代码，毕竟有时候不是完全向后兼容的。)
> - 使用合适的选择器。(jQuery 提供非常丰富的选择器，选择器是开发人员最常使用的功能，但是使用不同选择器也会带来性能问题。建议使用简凖选择器，如 i 选择器、类选择器，不要将 i 选择器嵌套等。)
> - 以数组方式使用 jQuery 对象。(使用 jQuery 选择器获取的结果是一个 jQuery 对象。然而， jQuery 类库会让你感觉正在使用一个定义了索引和长度的数组。在性能方面，建议使用简单的 for 或者 while 循环来处理，而不是$. each()，这样能使代码更快。)
> - 每一个 JavaScript 事件（例如 click、 mouseover 等）都会冒泡到父级节点。当需要给多个元素绑定相同的回调函数时，建议使用事件委托模式。
> - 使用 join( )来拼接字符串。(使用 join( )拼接长字符串，而不要使用“+”拼接字符串，这有助于性能优化，特别是处理长字符串的时候。)
> - 合理利用 HTML5 中的 data 属性。(HTML5 中的 data 属性有助于插入数据，特别是前、后端的数据交换；jQuery 的 data( )方法能够有效地利用 HTML5 的属性来自动获取数据。)

51. 哪些方法能提升移动端 CSS3 动画体验？

> - 尽可能多地利用硬件能力，如使用 3D 变形来开启 GPU 加速，例如以下代码。
>
> ```
> -webkit-transform: translate 3d(0, 0, 0);
> -moz-transform : translate3d(0,0, 0);
> -ms-transform : translate 3d(0,0,0);
> transform: translate3d(0,0,0)；
> ```
>
> 一个元素通过 translate3d 右移 500X 的动画流畅度会明显优于使用 left 属性实现的动画移动，原因是 CSS 动画属性会触发整个页面重排、重绘、重组。paint 通常是最耗性能的，尽可能避免使用触发 paint 的 CSS 动画属性。
>
> 如果动画执行过程中有闪烁（通常发生在动画开始的时候），可以通过如下方式处理。
>
> ```
> -webkit-backface-visibility:hidden;
> -moz-backface-visibility:hidden；
> -ms-backface-visibility:hidden ;
> backface-visibility:hidden；
> -webkit-perspective：1000；
> -moz-perspective：1000；
> -ms-perspective：1000；
> perspective：1000;
> ```
>
> - 尽可能少使用 box- shadows 和 gradients，它们往往严重影响页面的性能，尤其是在一个元素中同时都使用时。
> - 尽可能让动画元素脱离文档流，以减少重排，如以下代码所示。
>
> ```
> position:fixed；
> position:absolute;
> ```

52. dom 树节点和渲染树节点一一对应吗，有什么是 dom 树会有，渲染树不会有的节点
53. CSS 会阻塞 dom 解析吗？
54. requestIdleCallback 是干什么用的
55. 浏览器的渲染原理
56. 浏览器的渲染过程
57. 关键渲染路径详述
58. 避免回流的方式
59. 跨域的方式
60. 前端的网络安全如何防御（xss，csrf）
61. cookies 的保护方式
62. 浏览器的缓存机制
63. 什么文件用强缓存，什么文件用协商缓存
64. React-Native 的原理，优缺点
65. react 的虚拟 dom 和 diff 描述
66. react 渲染优化（class，hook）
67. react 的 context 的使用场景
68. node 和后端知识
69. mysql 和 mongo 的区别，使用情景
70. node 有什么情况会导致内存溢出
71. node 的内存分配
72. event loop（浏览器和 node）
73. 首屏优化方案
74. 在 App 中如何实现前端资源离线缓存（方案）
75. 算法
76. const arr = [101,19,12,51,32,7,103,8]; 1.找出连续最大升序的数量 2.找出不连续最大升序的数量
77. 浏览器的输入 url 后的过程
78. js 异步方式
79. promise.resolve 是干嘛的
80. promise.then 如何实现链式调用
81. promise.then 不返还一个 promise 还能用 then 吗
82. promise.finally 的作用，如何自己实现 finally
83. promise 原理
84. webpack 的异步加载如何实现
85. webpack 的分包策略
86. 跨域方式有什么
87. jsonp 的原理
88. csrf 防御手段
89. cookie 的 samesite 属性作用
90. js 对象循环引用会导致什么问题
91. react 如何阻止原生默认事件
92. react 的 fiber 节点树是什么数据结构，为什么要用这样的数据结构
93. react 异步渲染原理，优先级如何划分
94. react hook 有自己做一些自定义的 hook 吗
95. react key 的原理
96. react 如何实现函数式调用组件，toast.show()
97. react 新增了什么生命周和删除了什么生命周期，为什么要删除
98. node 后端知识
99. node 对于 option 请求如何处理
100.  node 如何处理 cors 跨域
101.  ES modules 和 commonjs 的区别
102.  node 的 event loop 和浏览器的区别
103.  dns 查询过程，dns 用什么协议发起 dns 查询的
104.  tcp 和 udp 区别
105.  tcp 的三次握手和四次挥手
106.  协商缓存和强缓存的区别
107.  https 协议握手大概过程
108.  对称加密和非对称加密的区别
109.  非对称加密，私钥和公钥的区别
110.  https 证书的作用
111.  如何埋点，为什么用 1\*1 像素的 gif 图片做上报
112.  如何定义首屏
113.  算法
114.  从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。2 ～ 10 为数字本身，A 为 1，J 为 11，Q 为 12，K 为 13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。

```
// 示例 1:
// 输入: [1,2,3,4,5]
// 输出: True

// 示例 2:
// 输入: [0,0,1,2,5]
// 输出: True

// 限制：
// 数组长度为 5
// 数组的数取值为 [0, 13] .
```

114. 绑定事件有多少种方式
115. 事件触发的流程，捕获和冒泡
116. 捕获阶段能终止吗
117. 终止冒泡阶段有哪些
118. 如果实现 one 绑定事件
119. 事件委托的原理
120. event.target 和 event.currtager 的区别
121. 浏览器显示一个图片有什么方式
122. 如何获取 url 中的?后的参数
123. 浏览器的内存回收机制 标记清除还是引用计数？
124. 如何解决跨域
125. 什么是简单请求什么复杂请求
126. const 和 let 有什么区别
127. ES6 常用的 api 有哪些
128. 数组断引用的方式有什么
129. Base64 图片有什么问题
130. node 后端知识
131. Http 强缓存和协商缓存用的是什么字段，整体流程是怎样
132. Https 原理
133. Https 第一次请求会携带什么
134. Ca 证书的内容是什么
135. Https2.0 的特性
136. xss 攻击原理的防御方式
137. Csrf 攻击原理和防御方式
138. 二进制分帧的具体是什么
139. Keep alive 和多路复用的区别
140. Option 请求的作用
141. Node gc 方式
142. 新生代和老生代的区别
143. 新生代内存地址移动到老生代内存地址的过程
144. 长列表优化方案
145. 首屏优化方案
146. Node 如何保证第三方接口的稳定性
147. 浏览器白屏原因
148. 页面打开后 cpu 和内存快速增长，如何定位问题，可能有什么问题
149. 长列表优化，以及长列表中，如果带搜索功能如何实现
150. 为什么使用 RN
151. 有 100 匹马，场地只有 4 条跑道，得出最快的 4 只马需要多少轮 Lam：100 匹马，4 个赛道，找出跑最快的 4 匹马。已知函数 fn1 会随机返回 1-5 的整数，要求基于 fn1 编写 fn2，要随机生成 1-7，fn2 内不能使用系统的随机 api，只能调用 fn1 获取随机数.
152. Serverless 的优缺点，前端的应用范围
153. 页面性能优化
154. 做过的专项的架构图
155. 对 JavaScript 的 Api 可以手写。
156. bind
157. new
158. promise
159. 浏览器的加载原理，回流重绘，url 输入后的流程，关键渲染路径等....
160. 框架的原理，了解你最常用的框架的内部原理以及实现，包括思想等。
161. 浏览器和 node 的 GC 原理
162. 浏览器和 node 之间 eventLoop 的区别
163. webpack 的基本原理
164. 数据库，redis，nginx 的一些基本概念以及基本原理和优化。
165. 对于前端页面的优化方案，包括首屏加载，资源整合，网络优化，长列表优化等
166. 网络安全，xss，csrf，cookies 保护等
167. 网络知识
168. tcp
169. https 和 http
170. dns
171. udp
172. 算法和数据结构
173. 基本常用排序
174. 链表操作
175. 树结构操作
176. 贪心算法
177. 回溯算法
178. 双指针操作
179. 哈希表
180. 动态规划
181. webpack 中 chunkHash 与 contentHash 区别
182. 写过 webpack 的 loader 和 plugin 么；
183. webpack 处理 image 是用哪个 loader，限制成 image 大小的是
184. webpack 将 css 合并成一个
185. webpack 的摇树对 commonjs 和 es6 module 都生效么，原理是；
186. 实现一下「模版字符串」功能；
187. 实现一下 Promise.all (Promise 不用写)；
188. 怎么实现响应式布局的；
189. css flex 的各个属性值；
190. css 动画 animation 各个时间值含义；
191. css 如何实现让一个元素旋转并横向移动，如果只用一个 css 属性；
192. less 与 sass 区别，技术选型时如何取舍；
193. ES6 symbol 如何使用以及使用场景；
194. ES6 Proxy 如何使用以及使用场景，说说 Reflect；
195. generator 有什么应用场景;
196. async await 如何实现的；
197. git reset 与 revert 区别，revert 多个 mr 改如何处理；
198. git 如何撤回 add 后的内容；
199. http2 与 http1.1 区别，了解 http3 么，说说；
200. tcp 与 udp 的区别；
201. 手写在 给定的 n 个数中随机取出 m 个数，要求等概率；
202. 手写一下防抖节流函数；
203. 设计实现一个「星级评分」组件；
204. 说说 http 缓存；
205. call、apply、bind 三者的区别，如何实现 bind；
206. 请实现 find 函数，使下列的代码调用正确。

```
约定：
title 数据类型为 String
userId 为主键，数据类型为 Number
var data = [
{userId: 8, title: 'title1'},
{userId: 11, title: 'other'},
{userId: 15, title: null},
{userId: 19, title: 'title2'}
];
var find = function(origin) {
your code are here...
}
查找 data 中，符合条件的数据，并进行排序
var result = find(data).where({
'title': /\d$/
}).orderBy('userId', 'desc');

console.log(result);
=> [{ userId: 19, title: 'title2'}, { userId: 8, title: 'title1' }];
```

207. js 有哪些基本类型，说说 typeof 与 instanceof；
208. 说说 new 操作符；
209. 什么是 event loop；
210. Promise 的用法？了解 allSettled 方法么，怎么实现？
211. 说说闭包；
212. ES5 实现继承的方法;
213. 说说跨域；
214. commonJS 与 ES6 模块化区别；
215. webpack 了解么？loader、plugin 分别是干嘛的？如何实现一个 loader？
216. webpack 如何优化打包速度；
217. 说一下 css 盒模型，border-box 和 content-box 区别；
218. 说说 BFC；
219. 移动端响应式布局怎么实现的；
220. 说一说 flex 布局，有了解 Grid 么；
221. 有兼容 retina 屏幕的经历吗？如何在移动端实现 1 px 的线;
222. 说一下 react 组件的生命周期；
223. react 组件如何做性能优化，说说 pureComponent；
224. 调用 setState 之后发生了什么;
225. 了解 fiber 么？解决了什么问题？具体原理是；
226. 有用过 hooks 么？怎么看待 hooks？它的原理是；
227. 了解过 react 最新的一些动态么？time slice 、suspense、server component
228. 了解最近一些新技术么，webpack5 做了哪些新突破；
229. 为什么 vite、snowpack 可以比 webpack 快那么多？具体原理是；
230. 什么是 CSRF 攻击，怎么预防；
231. 为什么说用 css 实现动画比 js 动画性能好；
232. 什么是 合成层；
233. http2 与 http1.1 区别；
234. 说一说 http 缓存；
235. http 状态码；

> 304: **一般完整的体现是 304 Not Modified**
>
> - 一般情况是这样的，第一次请求接口都是返回 200 状态码，同时在响应头中携带着 Etag 键值对和 Last-Modified 键值对，那么当浏览器没有禁止缓存并且服务器认为客户端缓存的资源并没有过期的时候，那么就会开始判断，本地缓存了当前目标的资源但是不确定该缓存资源是否为最新版本的时候，就会发送一个条件请求，
> - 在第二次请求时，由于本地已经有缓存的目标资源且资源中的响应头存在上面所说的两个参数，那么在条件请求中它的请求头 request Headers 会带上两个请求参数：If-Modified-Since 和 If-None-Match，分别对应 Last-Modified 和 Etag 的数值，主要用于判断客户端缓存的资源是否是最新的，如果是最新的资源那么服务器就会返回 304 Not Modified 响应头，但是没有响应体，而客户端就会从本地缓存中读取资源，所以：当访问资源出现 304 访问的情况下其实就是先在本地缓存了访问的资源。
>   以下情况下不会出现 304 条件请求：
> - - 当服务端认为客户端缓存的资源已经过期了
> - - 客户端因为被禁缓存而导致本地缓存没有目标资源
> - - 缓存的目标资源并没有包含了 Last-Modified 或 ETag
>     以上情况服务端就会直接返回 HTTP/200 响应。

236. 路由器和交换机的区别；😨
237. 实现斐波纳切数，递归和非递归的时间复杂度分别是多少
238. 手写大数相加方法；
239. 实现一个方块的拖拽；
240. 问了一些项目的问题，以及相关技术细节；
241. 从一个 URL 输入到页面渲染，经历了哪些过程，尽可能的详细；
242. tcp 握手 回收过程，了解泛洪攻击么；
243. 说说 event loop（并出了一道题，写输出顺序）；
244. SSR 怎么做的，怎么保证同构？server 端的数据都 renderToSting 消费了，为什么还要给到 client 端；
245. js 的严格模式；
246. 说说 Iterator 的使用；
247. 说一说快速排序的过程；
248. node 如何捕捉错误，内存泄漏怎么排查；
249. 为什么要做 SSR；
250. E2E 测试怎么做的，怎么保证测试覆盖率和准确性；
251. 如何合理分配 node 服务资源；
252. hybrid 通信原理；
253. 如何看待小程序，它的技术原理是；
254. 设计一个协同文档的技术流程；
255. 离线包怎么做的，现在公司的 app 提供了哪些特殊能力；
256. 质量保障平台如何做的，项目中单元测试怎么做的，为什么要有 E2E 测试；
257. 希尔排序，堆排，快排；
258. this 指向问题，说出输出内容；
259. 如何设计一个组件库；
260. 用过 TypeScript 么，了解哪些新特性；
261. 说说 React Fiber...;
262. 为什么 Fiber 双向链表的结构可以解决递归慢的问题；
263. 了解设计模式么，说说单例模式的优缺点;
264. 职业规划；
265. 二维数组中的查找；
266. 从先序遍历还原二叉树
267. 手写一个版本比较函数；
268. 实现一下 cache request（请求过的数据不再请求）
269. 防抖节流；
270. 手写 Promise 及相关 api 实现；
271. 实现 bind、apply、call；
272. request cache；
273. 实现模版字符串；
274. es6 class 转成 es5 ；
275. 实现 Array flat 等相关 API；
276. 实现一个版本比较函数；...
